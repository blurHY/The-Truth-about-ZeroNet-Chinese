# 安全

这章讲零网安全。如果不太感兴趣或者没法理解，稍微看看就好。

-   每个站点都有公钥和私钥。输入 `http://127.0.0.1:43110/1HeLLo4uzjaLetFx6NH3PMwFP3qbRbTf3D/` 访问 ZeroHello - 其中， `1HeLLo4uzjaLetFx6NH3PMwFP3qbRbTf3D` 为公钥。只有站长有私钥，用来发布内容。
-   下载站点时，零网会连接已知节点并向它们索要文件。
-   没有私钥就无法更改网站内容。

## 错误的 SHA512

In ZeroNet, everybody hosts zites, but not all - only the zites they want. For example, if `Windows` hosts `ZeroMe`, and `iPad` wants to download it, `iPad` connects to `Windows` _directly_ and says:

-   **iPad**: Hey, _Windows_, give me `content.json` of `ZeroMe`.
-   **Windows**: Here it is: ...
-   **iPad**: Thanks! And I also need `index.html`, `js/all.js` and `css/all.css` of `ZeroMe`.
-   **Windows**: Here is `index.html`: ... But I have no `js/all.js` and `css/all.css`, sorry.

_Windows_ gave _iPad_ `index.html`, but where can _iPad_ find `js/all.js` and `css/all.css`? From other peers _Windows_ knows. But the problem is, if _Windows_ is malicious, he can only recommend peers that also didn't have those files.

-   **iPad**: Good bye, _Windows_.
-   **iPad**: ...Searching peers...
-   **iPad**: Hey, _MacOS_, you have `js/all.js` and `css/all.css` of `ZeroMe`?
-   **MacOS**: Of course I have! Here they are: ...

But _MacOS_ is a hacker! It gives wrong `js/all.js`, with an exploit. Boom! `Windows` has an infected `js/all.js`!

...In fact, no. Each zite has its public key and private key. Public key example is: `1BewKAyyiMZHY3AjQn65J6f6Rcb9p1h64K`. Public key is zite address.

In `content.json` of any zite, there is an SHA512 of each files and size of each file. **MacOS** gave **iPad** a file with other SHA512, so **iPad** says:

-   **iPad**: `css/all.css` is OK. `js/all.js`... isn't.
-   **iPad**: ...Adds _MacOS_ to black list...
-   **iPad**: Good bye, _MacOS_.
-   **iPad**: ...Searching peers...
-   **iPad**: Hey, _Linux_, you have `js/all.js` of `ZeroMe`?
-   **Linux**: Yes. Here it is: ...
-   **iPad**: Thanks. Good bye, _Linux_.

Now _iPad_ has full _ZeroMe_ and can show it to you.

That's how ZeroNet makes data secure with SHA512.

## 错误的`content.json`

Now _Linux_ needs _ZeroTalk_ (its public key is `1TaLkFrMwvbNsooF4ioKAY9EuxTBTjipT`):

-   **Linux**: You have `content.json` of `1TaLkFrMwvbNsooF4ioKAY9EuxTBTjipT`?
-   **MacOS**: Yes. Take it, please: ...

As we know, _MacOS_ is a hacker. It gives wrong `content.json`, with wrong SHA512. _Linux_ would ask _MacOS_ for `js/all.js`, and _MacOS_ would give _Linux_ file with exploit.

-   **Linux**: Thanks! ...Wait a minute. `content.json` is signed with wrong key.
-   **Linux**: ...Adds _MacOS_ to black list...
-   **Linux**: Good bye, _MacOS_.

_Linux_ is clever. `content.json` is signed with private key. _MacOS_ would have to steal private key or bruteforce it. But the latter is practically impossible. And you shouldn't let anybody steal zite's private key.

## 签名

Now, we know how data is signed. Only `content.json` is signed, and all other files are signed using `content.json` and its SHA512. It means that nothing can be changed without private key, and usual rainbow tables are useless.

## 沙盒

As ZeroNet cannot create a new server for every zite you visit, it creates a single server at `http://127.0.0.1:43110/`. So, some more security is needed. ZeroNet opens every zite in a restricted `<iframe>`, so _localStorage_ and some other things can not be used (because some zite would be able to access other zite's data).

ZeroNet also does not let zites escape from `<iframe>` - a special token is passed to `<iframe>`, zites use it to communicate with ZeroNet server for some low-level commands. As it changes when you reload the page, bruteforcing `wrapper_nonce` (the token) is the only way to escape `<iframe>`.

But how can data be passed to `<iframe>`? Only with query string. So, there is always a `wrapper_nonce` parameter in query string. So, if you expect query string be `?a=2`, in fact it is `?a=2&wrapper_nonce=e0ccdebc9a804cfd8ac9eaf78a4a03054acbd400ce981219037647922219fbcd`.

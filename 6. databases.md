# 创建数据库

今天咱建个博客站。

## 创建站点

我推荐直接创建新站点，因为更改一个写好的站点的数据库配置比较难调试。我还是会照常给你两种代码格式：一个用 ZeroFrame，另一个用我的库。

## 概览

零网内置 SQLite。当然，你自己也可以创建一个数据库，这不是很难。咱开始创建数据库吧。

## 数据源

零网中只有 _SELECT_ 语句是允许的，数据库是由 JSON 文件导入而成的，所以现在就写点 JSON 文件吧。

### `data.json`

依据传统，用户数据都放在 `data/*/data.json`文件。现在咱写个`data/admin/data.json`吧。创建一个数组`posts`，里面有几行数据。

```json
{
	"posts": [
		{
			"id": 1,
			"title": "Post 1",
			"content": "Post 1"
		},
		{
			"id": 2,
			"title": "Post 2",
			"content": "Post 2"
		}
	]
}
```

## 数据库模式

`dbschema.json` 是个简单的 JSON 文件，下面是个空数据库：

    {
        "db_name": "mydatabase",
        "db_file": "data/mydatabase.db",
        "version": 2,
        "maps": {},
        "tables": {}
    }

-   `db_name` 指数据库名，只用于调试。一个站点不能有多个数据库。
-   _SQLite_ 是单个文件，`db_file` 是其路径。
-   `version` 不是 _SQLite_ 版本，是零网的数据库的版本。
-   `maps` 数据库和文件之间的映射关系。
-   `tables` 表结构。

把 `dbschema.json` 复制到站点根目录。

### `json` 表

对于每个注册用户（站长或者是 ZeroID 用户），在`json`表里都有一条记录。零网需要这个表，否则会报错。

现在往文件里加点内容。

`dbschema.json`:

```json
{
	"db_name": "mydatabase",
	"db_file": "data/mydatabase.db",
	"version": 2,
	"maps": {},
	"tables": {
		"json": {
			"cols": [
				["json_id", "INTEGER PRIMARY KEY AUTOINCREMENT"],
				["directory", "TEXT"],
				["file_name", "TEXT"]
			],
			"indexes": [
				"CREATE UNIQUE INDEX path ON json(directory, file_name)"
			],
			"schema_changed": 1
		}
	}
}
```

### 添加表

再添加`posts`表

先设置表名

```json
    {
        "db_name": "mydatabase",
        "db_file": "data/mydatabase.db",
        "version": 2,
        "maps": {},
        "tables": {
            "json": {
                "cols": [
                    ["json_id", "INTEGER PRIMARY KEY AUTOINCREMENT"],
                    ["directory", "TEXT"],
                    ["file_name", "TEXT"]
                ],
                "indexes": ["CREATE UNIQUE INDEX path ON json(directory, file_name)"],
                "schema_changed": 1
            },
            "posts": {
                ...
            }
        }
    }
```

看 `json` 表的格式，每个表都由 `cols`, `indexes` 和 `schema_changed`组成。 `schema_changed` 就是表的版本，改变表后要增加这个值，这样每个节点才会重建数据库。

```json
    "posts": {
        "cols": [
            ...
        ],
        "indexes": [
            ...
        ],
        "schema_changed": 1
    }
```

`cols` 是列（column）的数组，每个列的第一个数组元素是列名 (SQL 关键字, 如`GROUP` 和 `UPDATE`是不允许的). 第二个是 _SQLite_ 列的类型 - `integer`, `float` 或 `text`.

```json
    "posts": {
        "cols": [
            ["id", "integer"],
            ["title", "text"],
            ["content", "text"],
            ["json_id", "integer references json(json_id)"]
        ],
        "indexes": [
            ...
        ],
        "schema_changed": 1
    }
```

注意到 `json_id` 列了吗? 这是 `dbschema.json` 中又一个奇怪的事情， 每个表都要有这个列。

`indexes` is index array. Any `CREATE INDEX` SQL command can be there. Index name doesn't mean anything.

    "posts": {
        "cols": [
            ["id", "integer"],
            ["title", "text"],
            ["content", "text"],
            ["json_id", "integer references json(json_id)"]
        ],
        "indexes": [
            "CREATE UNIQUE INDEX post_id ON posts(id)"
        ],
        "schema_changed": 1
    }

Now, we have a DB. Right now, sign `content.json`. You'll find a new file, `data/mydatabase.db` (from `db_file` property of `dbschema.json`). This is _SQLite_ database. I recommend _SQLiteStudio_ for browsing these files. Right now, you'll find empty `json` and `post` tables, and a special `keyvalue` table. This is ZeroNet internal table, usually we don't need to touch it.

### 映射表

#### `to_table`

We have an empty table with correct structure. But who needs empty tables? Let's fill `posts` table from `data/admin/data.json`.

Remember empty `maps` object from `dbschema.json`?

    ...
    "version": 2,
    "maps": {},
    "tables": {
        ...

Let's change it.

    "maps": {
        "admin/data.json": {
            "to_table": [
                {
                    "node": "posts",
                    "table": "posts"
                }
            ]
        }
    }

Object name `admin/data.json` is _regular expression_. Each file that matches this expression is checked against object value. Right now you can see only `to_table` property. That means that each row from `posts` object in any file that matches _regular expression_ (`admin/data.json`) is added to `posts` table.

Let's sign `content.json` and check database content again. See that `json_id` column in `posts` table? And that row in `json` table? That's OK. `json_id` in `posts` table maps to `json_id` in `json` table. And from `json` table we know, which file added a row. You probably think that's not necessary, but that's not necessary only right now.

## 数据库的读权限

Let's start writing code. Create empty `js/index.js`. Include it and `js/ZeroFrame.js` to `index.html`.

Remember how to call ZeroFrame? Let's call `dbQuery`:

    +-------------------------------------------------------------------------+
    |                                 dbQuery                                 |
    +-------------------------------------------------------------------------+
    | Run a query on the sql cache                                            |
    +-------------------------+-----------------------------------------------+
    | Parameter               | Description                                   |
    +-------------------------+-----------------------------------------------+
    | query                   | Sql query command                             |
    +-------------------------+-----------------------------------------------+
    | Return: Result of query as array or object with "error" property        |
    +-------------------------------------------------------------------------+

    var zeroFrame = new ZeroFrame();

    zeroFrame.cmd("dbQuery", ["SELECT * FROM posts"], function(posts) {
        if(posts.error) {
            console.warn(posts.error);
            return;
        }

        console.log(posts);
    });

Open console, reload page, and you'll see the following:

    Array [ Object, Object ]
            Object {
                content: "Post 1",
                id: 1,
                json_id: 1,
                title: "Post 1"
            }

We'll cover dynamic data changing and design in the following parts. For now, you can directly change `data/admin/data.json`, sign `content.json` and reload zite to see what changes.
